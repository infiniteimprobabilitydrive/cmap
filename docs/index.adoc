:source-highlighter: highlightjs

== The art of manufacturing types

Simon Pettersson +
<http://simonvpe.github.io>


[%notitle]
== Auto

`auto`

[%notitle]
=== ...
`c++03`
[source,c++]
----
typedef PyMessageFactory::ClassesByMessageMap::iterator iterator;
for (iterator it = self->classes_by_descriptor->begin();
     it != self->classes_by_descriptor->end(); ++it) {
    ...
}
----

[%notitle]
=== ...
`c++11`
[source,c++]
----
for(auto& item : *self->classes_by_descriptor)
    ...
}
----

[%notitle]
=== ...
`auto` all the things?

[%notitle]
=== ...
was in signed, unsigned, 8/16/32/64 bits, happy? sad? +
[source,c++]
----
auto square(auto arg)
{ return arg*arg; }
----
¯\\_(ツ)_/¯

[%notitle]
=== ...
no lambdas without `auto`
[source,c++]
----
const auto lambda = [](int arg)
{ return arg*arg; };
----

[%notitle]
=== ...
i knew all of this, where are you going?

== Factories
manufacture all the things!

[%notitle]
=== ...
a brush factory
[source,c++]
----
auto make_brush = [](color_t color) {
    return [color](auto canvas) {
        canvas.apply_color(color);
    };
};
----

[source,c++]
----
const auto paint_it_yellow = make_brush(yellow);
paint_it_yellow(canvas);
----

[%notitle]
=== ...
can we combine it with `constexpr`?

[%notitle]
=== ...
image::graph.png[canvas,size=800px]

[%notitle]
=== ...
[source,c++]
----
struct outcome {
    constexpr outcome(bool s, int v) : success{s}, value{v} {}
    const bool success;
    const int value;
};
----

[%notitle]
=== ...
[source,c++]
----
constexpr auto make_terminal = [](int key, int value) {
    return [key,value](const auto _key) -> outcome {
        return { _key == key, value };
    };
};

constexpr auto make_branch = [](auto left, auto right) {
    return [left,right](int key) -> outcome {
        const auto result = left(key);
        if(result.success)
            return {true, result.value};
        return right(key);
    };
};
----

=== ...
polish with an API

[%notitle]
=== ...

a compile time lookup table
[source,c++]
----
constexpr auto lkup = make_lookup(
  map('A',13),
  map('B',55),
  map('C',87)
);

const int my_native_array[ lkup['B'] ];
----

[%notitle]
== ...
image::amiga500.jpg[canvas,size=800px]

[%notitle]
=== ...
C= Amiga 500

[%step]
* Released 1987
* Motorola 68000 CPU ( -> Freescale -> NXP )
* 32 bit registers, 16 bit data bus
* 7.16 MHz
* 512 kB RAM
* Native support for C++17 (after a lot of hacking)

=== BSP

[source,c++]
----
enum class Register {
    PRA, PRB, DDRA, DDRB, TALO, TALHI, TBLO, TBHI,
    TODLO, TODMID, TODHI, SDR, ICR, CRA, CRB
};

constexpr auto ciaa = make_lookup(
    map(Register::PRA,    reg{0xBFE001, Width::B, Access::R}),
    map(Register::PRB,    reg{0xBFE101, Width::B, Access::R}),
    map(Register::DDRA,   reg{0xBFE201, Width::B, Access::R}),
    map(Register::DDRB,   reg{0xBFE301, Width::B, Access::R}),
    map(Register::TALO,   reg{0xBFE401, Width::B, Access::R}),
    map(Register::TALHI,  reg{0xBFE501, Width::B, Access::R}),
    ...
----

[%notitle]
=== ...

[source,c++]
----
write_w<COLOR17>(0x0444);
write_w<COLOR18>(0x0999);
write_w<COLOR19>(0x0FFF);  
write_l<COP1LCH>(&copperlist);
read_w<COPJMP1>();
write_w<DMACON>(0x83A0);
----
* Compile time error writing to a RO register
* Compile time error reading from a WO register
* Compile time error reading/writing too many bits
* Generates the smallest code possible, same performance as macros

== DEMO HERE

== Thanks for listening
